# DDoS攻撃の詳細

## UDP Flood

**攻撃手法**: 大量のUDPパケットでネットワーク帯域を飽和させる攻撃
**特徴**:

- connectionlessプロトコルを悪用
- 送信元IPの偽装が容易
- 高い帯域消費

**影響**: ネットワーク全体の可用性低下
**検出方法**: 異常なUDPトラフィック量の監視

## SYN Flood

**攻撃手法**: TCP接続開始パケット（SYN）を大量送信してサーバーリソースを枯渇
**特徴**:

- TCP 3-way handshakeの脆弱性を悪用
- 半開き接続でメモリ消費
- 送信元IPの偽装

**影響**: 新規接続の受け入れ不可
**検出方法**: 半開き接続数の異常増加

## ICMP Flood

**攻撃手法**: 大量のICMPパケットでネットワーク負荷を発生
**特徴**:

- Ping of Death等の変種
- ルーターやファイアウォールに負荷
- 帯域幅の消費

**影響**: ネットワーク性能の劣化
**検出方法**: ICMPトラフィックの異常増加

## HTTP Flood

**攻撃手法**: 正常なHTTPリクエストに見せかけた大量リクエスト
**特徴**:

- Layer 7（アプリケーション層）攻撃
- 正常なトラフィックとの区別困難
- 低帯域でも効果的

**影響**: Webサーバーのリソース枯渇
**検出方法**: リクエスト数の異常増加、レスポンス時間の悪化

### HTTP Flood攻撃の種類

#### **Basic HTTP Floods**

- 同じページに大量のHTTPリクエスト
- 限定されたIP、User-Agent、Referrerを使用
- 比較的検出が容易

#### **Randomized HTTP Floods**

- ランダムなURL、IP、User-Agentを使用
- 正常なトラフィックに紛れやすい
- 検出が困難

#### **Cache-Bypass HTTP Floods**

- キャッシュされていないコンテンツを狙い撃ち
- CDNやキャッシュを迂回
- 直接オリジンサーバーに負荷

### 防御手段

#### **1. レート制限実装**

- **IP別制限**: 同一IPからのリクエスト数を制限
- **エンドポイント別制限**: 重要なAPIに厳格な制限を適用
- **スライディングウィンドウ**: 時間窓を移動させた柔軟な制限
- **分散環境対応**: Redisなどで状態を共有

#### **2. 多層キャッシュ戦略**

- **CDNレベル**: 静的コンテンツの高速配信
- **アプリケーションレベル**: 動的コンテンツの一時保存
- **データベースレベル**: クエリ結果の再利用
- **キャッシュ無効化**: 適切な更新戦略

#### **3. リクエスト正規化**

- **パラメータ制限**: 異常な数や長さのパラメータを拒否
- **値の検証**: 期待される範囲外の値を除外
- **正規化処理**: 同一内容の異なる表現を統一
- **早期拒否**: 不正なリクエストの早期検出

#### **4. Bot検知とフィルタリング**

- **行動パターン分析**: 人間とBotの行動の違いを検出
- **User-Agent検証**: ブラウザ情報の妥当性確認
- **リクエスト間隔**: 異常に規則的なアクセスパターン
- **機械学習**: AIによる高度な判定

#### **5. 段階的制限戦略**

- **認証系エンドポイント**: 最も厳格な制限（例：10回/分）
- **一般APIエンドポイント**: 通常の制限（例：100回/分）
- **静的リソース**: 緩い制限（例：1000回/分）
- **動的調整**: 負荷状況に応じた制限値変更

#### **6. 監視とアラート**

- **リアルタイム監視**: 異常なトラフィックパターンの即座検出
- **アラート通知**: 攻撃発生時の迅速な通知（Slack、メール等）
- **ログ分析**: 攻撃パターンの事後分析
- **統計レポート**: 定期的なセキュリティ状況報告

### Vercelでの現状

- **自動保護**: 基本的なDDoS保護のみ
- **制限**: 詳細なパターン分析なし
- **必要な追加実装**: 上記の防御手段をアプリケーション層で実装

## Slowloris

**攻撃手法**: 接続を長時間維持してサーバーの接続プールを枯渇
**特徴**:

- 低帯域で実行可能
- 接続を意図的に遅延
- 検出が困難

**影響**: 新規接続の受け入れ不可
**検出方法**: 長時間接続の異常増加

### Slowloris攻撃の仕組み

- **部分的なHTTPリクエスト**: ヘッダーを少しずつ送信
- **接続維持**: Keep-Aliveヘッダーで接続を保持
- **タイムアウト回避**: 定期的に追加データを送信
- **リソース枯渇**: サーバーの最大接続数に到達

### 防御手段

#### **1. 接続タイムアウト設定**

- **短いタイムアウト**: 不完全なリクエストの早期切断
- **読み取りタイムアウト**: データ受信待機時間の制限
- **Keep-Alive制限**: 持続接続の時間制限
- **アイドル接続監視**: 非アクティブ接続の検出

#### **2. 接続数制限**

- **IP別接続制限**: 同一IPからの同時接続数制限
- **接続プール管理**: 最大接続数の適切な設定
- **接続キューイング**: 新規接続の待機列管理
- **優先度制御**: 重要な接続の優先処理

#### **3. リクエスト完全性チェック**

- **ヘッダー完全性**: HTTPヘッダーの完全性確認
- **Content-Length検証**: 宣言されたサイズとの一致確認
- **リクエストライン検証**: HTTPメソッドとURLの妥当性
- **早期拒否**: 不完全なリクエストの即座拒否

#### **4. プロキシ・ロードバランサー活用**

- **リバースプロキシ**: フロントエンドでの接続処理
- **接続プーリング**: バックエンドへの効率的な接続管理
- **バッファリング**: リクエストの完全受信後転送
- **負荷分散**: 複数サーバーでの接続分散

#### **5. レート制限との組み合わせ**

- **新規接続制限**: 短時間での大量接続を制限
- **緩慢なリクエスト検出**: 異常に遅いデータ送信の検出
- **行動パターン分析**: 正常ユーザーとの差異検出
- **IP評価システム**: 疑わしいIPの段階的制限

#### **6. サーバー設定最適化**

- **非同期処理**: イベント駆動型サーバーの採用
- **軽量スレッド**: 接続あたりのリソース消費削減
- **効率的なI/O**: ノンブロッキングI/O処理
- **メモリ管理**: 接続ごとのメモリ使用量最適化

### Vercelでの現状

- **部分保護**: 基本的なタイムアウト設定あり
- **制限**: 高度な接続管理機能なし
- **Edge Network**: 分散処理で影響軽減
- **必要な追加対策**: アプリケーション層での接続制御

### 開発者の制御範囲と実用的な判断

#### **アプリケーション開発者には制御不能**

Slowloris攻撃は**TCP接続レベル**で発生するため、以下の理由でアプリケーション開発者には直接的な対策が困難：

- **接続管理**: OS・ミドルウェアレベルの機能
- **タイムアウト設定**: インフラ層の設定領域
- **接続プール制御**: サーバー・プロキシレベルの機能
- **バッファリング**: ネットワーク層の処理

#### **現在のVercelレベル対応で十分なケース**

- **ポートフォリオサイト**: 個人・小規模プロジェクト
- **プロトタイプ開発**: 概念実証・初期開発段階
- **低トラフィック**: 月間数万PV程度のサイト
- **開発・テスト環境**: 内部利用メインの環境

#### **具体的な判断目安**

| 項目                 | Vercelで十分 | 高度な保護を検討 | 必須               |
| -------------------- | ------------ | ---------------- | ------------------ |
| **月間PV**           | ～10万PV     | 10万～100万PV    | 100万PV～          |
| **同時接続数**       | ～1,000      | 1,000～10,000    | 10,000～           |
| **ユーザー数**       | ～1,000人    | 1,000～10,000人  | 10,000人～         |
| **収益規模**         | 趣味・無料   | 月売上～100万円  | 月売上100万円～    |
| **サービス停止影響** | 軽微         | 中程度の損失     | 重大な損失         |
| **データ種別**       | 公開情報     | 個人情報一部     | 機密・決済情報     |
| **可用性要求**       | 特になし     | 99%程度          | 99.9%以上          |
| **攻撃対象度**       | 低           | 中程度           | 高（知名度・価値） |

#### **ビジネス利用では高度なインフラ保護が必要**

本格的なビジネスアプリケーションでは、以下の場合に接続管理を備えたインフラの利用を検討：

**要件例**:

- **高可用性要求**: サービス停止が直接的な損失につながる
- **大量トラフィック**: 月間数百万PV以上の処理
- **機密データ扱い**: 顧客情報・決済情報の処理
- **SLA保証**: 顧客との可用性保証契約

#### **段階別の実用判断**

**フェーズ1: スタートアップ・個人（Vercelで十分）**

```
- トラフィック: 月間1万～10万PV
- ユーザー: 数百～数千人
- 収益: 実験・初期段階
- 攻撃リスク: 低（知名度が低い）
→ Vercelの基本保護で開始
```

**フェーズ2: 成長期（保護強化検討）**

```
- トラフィック: 月間10万～100万PV
- ユーザー: 数千～1万人
- 収益: 月数十万円～数百万円
- 攻撃リスク: 中（認知度上昇）
→ Cloudflare等の追加検討
```

**フェーズ3: 本格運用（高度な保護必須）**

```
- トラフィック: 月間100万PV～
- ユーザー: 1万人～
- 収益: 月数百万円～
- 攻撃リスク: 高（標的価値高）
→ 包括的セキュリティ体制
```

**推奨インフラ構成**:

```
┌─────────────────┐
│ Cloudflare      │ ← 完全なSlowloris対策
│ + WAF           │   高度な接続管理
├─────────────────┤
│ Vercel/Railway  │ ← アプリケーション実行
│ + Application   │   ビジネスロジック
│ Security        │
└─────────────────┘
```

#### **段階的なセキュリティ向上**

1. **初期段階**: Vercelの基本保護で開発開始
2. **成長段階**: トラフィック増加に応じてCloudflare等を追加
3. **本格運用**: 包括的なセキュリティ体制構築

**結論**: Slowlorisは開発者の制御範囲外の攻撃であり、現段階ではVercelの基本保護で十分。ビジネス規模拡大時には、専門的な接続管理機能を持つインフラへの移行を検討する。

## POST攻撃

**攻撃手法**: 大量のPOSTリクエストでサーバーに処理負荷をかける
**特徴**:

- データベース操作を強制
- CPU/メモリ集約的な処理
- 正常なフォーム送信に偽装

**影響**: アプリケーション性能の劣化
**検出方法**: POST頻度の異常増加、DB負荷の上昇

### POST攻撃の仕組み

- **重い処理の悪用**: フォーム送信、ファイルアップロード、検索処理
- **データベース負荷**: INSERT、UPDATE、複雑なクエリの実行
- **外部API呼び出し**: メール送信、通知、外部サービス連携
- **リソース消費**: CPU、メモリ、ディスクI/Oの集約的使用

### レート制限による防御（効果的）

#### ** レート制限が効果的な理由**

- **L7攻撃**: HTTPリクエストレベルでの攻撃
- **リクエスト単位**: 個別のPOSTリクエストを制限可能
- **早期ブロック**: 処理前の段階で攻撃を防御
- **識別可能**: IP、セッション、ユーザー別の制限

#### **段階的レート制限戦略**

**1. 全体的な制限（Middleware）**

- **目的**: 基本的なPOST攻撃の防御
- **対象**: 全POSTエンドポイント
- **制限例**: 60回/分（IP別）

**2. エンドポイント別制限**

- **重いエンドポイント**: 厳格な制限
  - お問い合わせフォーム: 5回/分
  - ファイルアップロード: 10回/時間
  - パスワードリセット: 3回/日
- **軽いエンドポイント**: 緩い制限
  - いいねボタン: 100回/分
  - 検索API: 30回/分

**3. ユーザー別制限**

- **未認証ユーザー**: 最も厳格
- **認証済みユーザー**: 中程度
- **プレミアムユーザー**: 緩い制限

#### **追加の防御手段**

**1. リクエストサイズ制限**

- **ペイロード制限**: 大きなPOSTデータの拒否
- **ファイルサイズ**: アップロードファイルの制限
- **フィールド数**: フォーム項目数の制限

**2. 処理時間制限**

- **タイムアウト設定**: 長時間処理の中断
- **非同期処理**: 重い処理のバックグラウンド実行
- **キューイング**: 処理の分散化

**3. 入力検証強化**

- **必須項目チェック**: 不完全なデータの早期拒否
- **データ形式検証**: 異常なデータの検出
- **ビジネスルール**: 正当性の確認

**4. キャッシュ活用**

- **結果キャッシュ**: 同一処理結果の再利用
- **重複排除**: 同一内容の連続投稿防止
- **一時保存**: 処理負荷の分散

#### **T3スタックでの実装アプローチ**

**Next.js Middleware**

- 全POSTリクエストの基本制限
- IP別、パス別の段階的制限
- 早期ブロックによる処理負荷軽減

**tRPC Procedure**

- 個別procedureの詳細制限
- ユーザー認証情報の活用
- ビジネスロジックとの連携

**API Routes**

- 特殊なエンドポイントの個別制御
- カスタム制限ロジック
- 外部API連携の制限

### Vercelでの対応状況

- **基本保護**: ペイロードサイズ制限のみ
- **レート制限**: 実装が必要
- **推奨対策**: Middleware + procedureレベルの制限実装

**結論**: POST攻撃はレート制限で効果的に防御可能。GET攻撃より重い処理が多いため、より厳格な制限設定が重要。
