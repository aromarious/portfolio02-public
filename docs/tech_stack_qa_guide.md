# 技術スタック Q&A ガイド

このドキュメントは、ポートフォリオで使用している技術について「なぜ採用したのか？」「他の選択肢と比較してどうなのか？」と聞かれた際に、説得力のある回答をするための想定問答集です。

---

## Frontend Ecosystem

### Next.js 16 (App Router)

**Q: なぜこれを選んだのですか？**
**A:** 現代のReact開発のデファクトスタンダードであり、特に **Server Components (RSC)** によるパフォーマンス最適化と、SEOに強いアーキテクチャが標準で手に入るからです。また、Vercelとの親和性が高く、Edge Runtimeへのデプロイが容易な点も、今回の「グローバル・パフォーマンス」という要件に合致しました。

**Q: Pages Routerではだめだったのですか？**
**A:** つくれないことはありませんが、RSCによる「コンポーネント単位のサーバー/クライアント分離」ができません。App Routerを採用することで、クライントバンドルサイズ（JavaScriptの転送量）を大幅に減らし、Core Web Vitalsのスコアを向上させることができます。また、将来的なReactのエコシステムはRSC前提にシフトしていくため、今学ぶならApp Routerが最適だと判断しました。

### Tailwind CSS

**Q: クラス名が長くなって読みづらくないですか？**
**A:** 確かにHTMLは長くなりますが、それ以上に「命名コストからの解放」と「コンポーネントのカプセル化」のメリットが大きいです。従来のCSS設計（BEMなど）ではクラス名の管理が大変でしたが、Tailwindならユーティリティクラスを組み合わせるだけです。また、Reactコンポーネント内にスタイルが閉じ込められるため、ファイルを削除すればスタイルも消え、CSSのゴミが残りません（Dead Code Elimination）。

**Q: CSS-in-JS (Emotion/Styled-components) との比較は？**
**A:** Server Components時代において、実行時のCSS生成コストがかかるCSS-in-JSはパフォーマンスのボトルネックになり得ます。Tailwindはビルド時に静的なCSSを生成するため、ランタイムオーバーヘッドがゼロで、RSCとの親和性が高いため採用しました。

---

## Backend & Data

### tRPC v11

**Q: REST APIやGraphQLではない理由は？**
**A:** 個人〜小規模チーム開発において、**開発速度と安全性のバランスが優れている**からです。RESTやGraphQLでは、バックエンドとフロントエンドの間で型定義の同期（OpenAPIの生成など）が必要ですが、tRPCならバックエンドのTypeScript関数をそのままフロントエンドから呼ぶ感覚で実装でき、自動的に型がつきます。スキーマ管理の手間が少なくなります。

**Q: フロントエンドとバックエンドが密結合になりませんか？**
**A:** はい、密結合になります。しかし、今回はMonorepo構成であり、フロントとバックが同じリポジトリにあるため、密結合であることはむしろ「変更に強い」というメリットになります。バックエンドを変えればフロントエンドで型エラーが出るため、リファクタリングが恐ろしく簡単になります。モバイルアプリなど外部クライアントへの提供が必要になった段階で、その部分だけOpenAPI化すれば良いという判断です。

### Drizzle ORM

**Q: Prismaの方が有名ですが、なぜDrizzle？**
**A:** **Cold Start対策**と**SQLへの理解**のためです。PrismaはRust製のバイナリエンジンを動かすため、特にサーバーレス環境（Edge Functionsなど）では起動が遅くなる問題があります。Drizzleは単なるTypeScriptのラッパーに近く、非常に軽量で起動が高速です。また、Prisma独自のDSLではなく、SQLに近い構文で書けるため、SQLの知識がそのまま活き、隠蔽されすぎない点が気に入っています。

### Supabase (PostgreSQL)

**Q: AWSやGCPではない理由は？**
**A:** **開発の立ち上がり速度**です。認証（Auth）、データベース（PostgreSQL）、リアルタイム更新（Realtime）がセットになっており、インフラ構築の手間をかけずにアプリケーションロジックの実装に入れます。AWS等の構成管理はIaCが必要で工数がかかりますが、Supabaseならその時間を機能開発に充てられます。また、中身は標準的なPostgreSQLなので、将来的な移行（Vendor Lock-inの回避）もしやすいです。

---

## Infrastructure & DevOps

### Vercel (Edge Network)

**Q: なぜEdge Runtimeなのですか？**
**A:** **ユーザー体験（レイテンシ）**と**セキュリティ**の両立です。日本のユーザーだけでなく、世界中どこからアクセスしても近くのサーバーで処理されるため高速です。また、DDoS攻撃やBotアクセスに対して、オリジンサーバーに到達する前の「エッジ」の段階でMiddlewareを使ってブロックできるため、セキュリティ強度が格段に上がります。

### Turborepo (Monorepo)

**Q: なぜMonorepo構成にしたのですか？**
**A:** **依存関係の一元管理**と**コード共有**のためです。例えば、DBのスキーマ定義やUIコンポーネント、ESLintの設定などを別パッケージ（`packages/*`）に切り出すことで、Webアプリ（`apps/nextjs`）以外のアプリ（例えば将来の管理画面やCLIツール）が増えても、同じ資産を再利用できます。Turborepoのキャッシュ機能により、変更がない部分のビルドやテストをスキップできるため、CIの時間も短縮できます。

### Biome

**Q: ESLint/Prettierではだめですか？**
**A:** だめではありませんが、Biomeは**非常に高速**です。Rust製で、LintとFormatを同時に高速で行います。CI/CDパイプラインにおいて、Lint/Formatの時間は積み重なると大きなロスになります。Biomeを採用することで、開発者の待ち時間を減らし、開発者体験（DX）を最大化しようという意図です。

### Dependabot

**Q: Renovateではない理由は？**
**A:** **GitHubネイティブな統合**を重視したためです。GitHubの設定ファイル（`dependabot.yml`）一つで完結し、追加のBot導入や複雑な権限設定が不要です。Weeklyでの定期実行や、セキュリティアップデートの自動作成など、個人開発におけるメンテナンスコストを最小限にするための機能としては十分であり、プラットフォーム標準の機能を使うことでシンプルさを保っています。
